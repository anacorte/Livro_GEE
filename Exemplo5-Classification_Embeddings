// =====================================================
// Área de Interesse (ROI)
// =====================================================
var geometry = ee.FeatureCollection('users/fabianoengflo/area');

// =====================================================
// Conjunto de Dados de Embeddings de Satélite
// =====================================================
var embeddings = ee.ImageCollection('GOOGLE/SATELLITE_EMBEDDING/V1/ANNUAL');

// =====================================================
// Configuração do Mapa
// =====================================================
Map.setOptions('SATELLITE');
Map.centerObject(geometry, 12);

// =====================================================
// Parâmetros Temporais
// =====================================================
var year = 2024;
var startDate = ee.Date.fromYMD(year, 1, 1);
var endDate   = startDate.advance(1, 'year');

var prevYear  = year - 1;
var startPrev = ee.Date.fromYMD(prevYear, 1, 1);
var endPrev   = startPrev.advance(1, 'year');

// =====================================================
// Sentinel-2 (2023 e 2024): Máscara e Composites
// =====================================================
// Função de máscara (QA60: bit 10 = nuvem; bit 11 = cirrus)
var maskS2sr = function(img) {
  var qa = img.select('QA60');
  var cloudBitMask  = 1 << 10;
  var cirrusBitMask = 1 << 11;
  var mask = qa.bitwiseAnd(cloudBitMask).eq(0)
               .and(qa.bitwiseAnd(cirrusBitMask).eq(0));
  return img.updateMask(mask)
            .divide(10000) // Escala para reflectância [0,1]
            .copyProperties(img, ['system:time_start']);
};

// Composto mediano anual (baixa nebulosidade)
var annualS2Composite = function(start, end) {
  var col = ee.ImageCollection('COPERNICUS/S2_SR_HARMONIZED')
    .filterDate(start, end)
    .filterBounds(geometry)
    .filter(ee.Filter.lte('CLOUDY_PIXEL_PERCENTAGE', 20))
    .map(maskS2sr);
  return col.median().clip(geometry);
};

// Gera composites 2023 e 2024
var s2_2023 = annualS2Composite(startPrev, endPrev);
var s2_2024 = annualS2Composite(startDate, endDate);

// Visualizações RGB e Falsa Cor
var rgbVis  = {bands: ['B4','B3','B2'], min: 0, max: 0.3};
var fccVis  = {bands: ['B8','B4','B3'], min: 0, max: 0.4};

// Adiciona camadas Sentinel-2
Map.addLayer(s2_2023, rgbVis, 'Sentinel-2 2023 (Mediana RGB)');
Map.addLayer(s2_2024, rgbVis, 'Sentinel-2 2024 (Mediana RGB)');
// (Opcional) Ative se quiser também ver Falsa Cor:
Map.addLayer(s2_2023, fccVis, 'Sentinel-2 2023 (Falsa Cor NIR)');
Map.addLayer(s2_2024, fccVis, 'Sentinel-2 2024 (Falsa Cor NIR)');

// (Opcional) Diagnóstico de quantidade de cenas por ano
var s2col2023 = ee.ImageCollection('COPERNICUS/S2_SR_HARMONIZED')
  .filterDate(startPrev, endPrev).filterBounds(geometry)
  .filter(ee.Filter.lte('CLOUDY_PIXEL_PERCENTAGE', 20));
var s2col2024 = ee.ImageCollection('COPERNICUS/S2_SR_HARMONIZED')
  .filterDate(startDate, endDate).filterBounds(geometry)
  .filter(ee.Filter.lte('CLOUDY_PIXEL_PERCENTAGE', 20));
print('Nº de cenas S2 (2023):', s2col2023.size());
print('Nº de cenas S2 (2024):', s2col2024.size());

// =====================================================
// Filtro e Mosaico (Ano Atual) – Embeddings
// =====================================================
var filteredEmbeddings = embeddings
  .filter(ee.Filter.date(startDate, endDate))
  .filter(ee.Filter.bounds(geometry));

print('Nº de imagens (ano atual) — Embeddings:', filteredEmbeddings.size());

var embeddingsImage = filteredEmbeddings.mosaic();
print('Imagem de embeddings (ano atual):', embeddingsImage);

// =====================================================
// Visualização RGB de Três Eixos (Embeddings)
// =====================================================
var visParams = {min: -0.3, max: 0.3, bands: ['A01', 'A16', 'A09']};
Map.addLayer(embeddingsImage.clip(geometry), visParams, 'Embeddings RGB');

// =====================================================
// Amostragem para Agrupamento (Embeddings)
// =====================================================
var nSamples = 1000;
var training = embeddingsImage.sample({
  region: geometry,
  scale: 10,
  numPixels: nSamples,
  seed: 100
});
print('Primeira amostra (embeddings):', training.first());

// =====================================================
// Função de Clusterização K-Means (Embeddings)
// =====================================================
var getClusters = function(nClusters) {
  var clusterer = ee.Clusterer.wekaKMeans({nClusters: nClusters})
    .train(training);
  return embeddingsImage.cluster(clusterer);
};

// =====================================================
// Geração de Mapas de Classes (3, 5, 10) – Embeddings
// =====================================================
var cluster3  = getClusters(3);
var cluster5  = getClusters(5);
var cluster10 = getClusters(10);

Map.addLayer(cluster3.randomVisualizer().clip(geometry), {},  'Embeddings: 3 Classes');
Map.addLayer(cluster5.randomVisualizer().clip(geometry), {},  'Embeddings: 5 Classes');
Map.addLayer(cluster10.randomVisualizer().clip(geometry), {}, 'Embeddings: 10 Classes');

// =====================================================
// Passo 1: Área por Classe (CSV) – Embeddings
// =====================================================
var clustered = cluster10; // Ajuste aqui se quiser outro k

var areaByClass = ee.Image.pixelArea()
  .addBands(clustered.rename('cluster'))
  .reduceRegion({
    reducer: ee.Reducer.sum().group({groupField: 1, groupName: 'cluster'}),
    geometry: geometry,
    scale: 10,
    maxPixels: 1e13,
    tileScale: 4
  });

print('Área por cluster (m²) — agrupado:', areaByClass);

var groups = ee.List(ee.Dictionary(areaByClass).get('groups'));
var fcAreas = ee.FeatureCollection(groups.map(function(g) {
  g = ee.Dictionary(g);
  var cl = ee.Number(g.get('cluster'));
  var area_m2 = ee.Number(g.get('sum'));
  return ee.Feature(null, {
    cluster: cl,
    area_m2: area_m2,
    area_ha: area_m2.divide(10000)
  });
}));

Export.table.toDrive({
  collection: fcAreas,
  description: 'areas_por_cluster_' + year,
  fileFormat: 'CSV'
});

// =====================================================
// Passo 2: Exportar Raster Clusterizado – Embeddings
// =====================================================
Export.image.toDrive({
  image: clustered.clip(geometry).toInt16(),
  description: 'clusters_' + year + '_k10',
  folder: 'GEE',
  fileNamePrefix: 'clusters_' + year + '_k10',
  region: geometry.geometry(),
  scale: 10,
  maxPixels: 1e13
});

// =====================================================
// Passo Opcional 3: Mudança Temporal (Cosseno '23 → '24) – Embeddings
// =====================================================
var embPrevCol = embeddings
  .filter(ee.Filter.date(startPrev, endPrev))
  .filter(ee.Filter.bounds(geometry));

print('Nº de imagens (ano anterior) — Embeddings:', embPrevCol.size());

embPrevCol.size().evaluate(function(nPrev) {
  if (nPrev && nPrev > 0) {
    var embPrev = embPrevCol.mosaic();
    var embCurr = embeddingsImage; // Ano corrente (já definido)

    // Garantia de bandas iguais usando a lista do ano corrente
    var commonBands = embCurr.bandNames();
    embPrev = embPrev.select(commonBands);
    embCurr = embCurr.select(commonBands);

    // Similaridade do cosseno entre vetores de embeddings por pixel
    var dot = embPrev.multiply(embCurr).reduce(ee.Reducer.sum());
    var normPrev = embPrev.pow(2).reduce(ee.Reducer.sum()).sqrt();
    var normCurr = embCurr.pow(2).reduce(ee.Reducer.sum()).sqrt();
    var cosSim = dot.divide(normPrev.multiply(normCurr))
                    .rename('cosine_similarity');

    Map.addLayer(
      cosSim.clip(geometry),
      {min: 0.2, max: 1.0},
      'Mudança temporal (cosseno ' + prevYear + ' → ' + year + ')'
    );

    Export.image.toDrive({
      image: cosSim.clip(geometry).toFloat(),
      description: 'cosine_similarity_' + prevYear + '_to_' + year,
      folder: 'GEE',
      fileNamePrefix: 'cosine_' + prevYear + '_' + year,
      region: geometry.geometry(),
      scale: 10,
      maxPixels: 1e13
    });
  } else {
    print('Sem imagens de embeddings para o ano anterior (' + prevYear + ') na ROI; passo de mudança temporal não executado.');
  }
});
